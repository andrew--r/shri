{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap b10b5d4ffd3573438c12","webpack:///./source/js/index.js","webpack:///./~/object-fit-images/dist/ofi.common-js.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_objectFitImages","_objectFitImages2","document","createElement","addEventListener","getStyle","el","parsed","style","getComputedStyle","fontFamily","props","propRegex","exec","fixOne","requestedSrc","ಠ","parsingSrcset","s","skipTest","supportsObjectFit","src","currentSrc","srcset","supportsCurrentSrc","window","picturefill","pf","_","ns","evaled","fillImg","reselect","curSrc","supported","srcAttr","nativeGetAttribute","srcsetAttr","Object","defineProperty","value","keepSrcUsable","backgroundImage","backgroundPosition","backgroundRepeat","test","i","Image","loop","naturalWidth","width","naturalHeight","height","backgroundSize","setTimeout","replace","descriptors","get","set","hijackAttributes","supportsObjectPosition","HTMLImageElement","prototype","getAttribute","name","this","setAttribute","nativeSetAttribute","String","fix","imgs","opts","startAutoMode","autoModeEnabled","querySelectorAll","length","body","e","target","tagName","watchMQ","bind","testImg"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GAE/B,YAMA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GEpDxF,GAAAG,GAAAf,EAAA,GFkDKgB,EAAoBL,EAAuBI,EEhDhDE,UAASC,cAAe,WAExBD,SAASE,iBAAiB,mBAAoB,YAC7C,EAAAH,EAAAF,cFyDK,SAASV,EAAQD,GG9DvB,YAYA,SAAAiB,GAAAC,GAIA,IAHA,GACAC,GADAC,EAAAC,iBAAAH,GAAAI,WAEAC,KACA,QAAAJ,EAAAK,EAAAC,KAAAL,KACAG,EAAAJ,EAAA,IAAAA,EAAA,EAEA,OAAAI,GAGA,QAAAG,GAAAR,EAAAS,GACA,IAAAT,EAAAU,GAAAC,cAAA,CAGA,GAAAT,GAAAH,EAAAC,EAOA,IANAE,EAAA,cAAAA,EAAA,uBAMAF,EAAAU,GAAAE,EAAA,CAEA,YAAAV,EAAA,cACA,MAIA,KAAAF,EAAAU,GAAAG,UACAC,IACAZ,EAAA,mBAEA,OAIA,GAAAa,GAAAf,EAAAgB,YAAAhB,EAAAe,GAEA,IAAAN,EAGAM,EAAAN,MACE,IAAAT,EAAAiB,SAAAC,GAAAC,OAAAC,YAAA,CACF,GAAAC,GAAAF,OAAAC,YAAAE,EAAAC,EAGAvB,GAAAU,GAAAC,eAAA,EAGAX,EAAAqB,IAAArB,EAAAqB,GAAAG,QAEAL,OAAAC,YAAAE,EAAAG,QAAAzB,GAAqC0B,UAAA,IAGrC1B,EAAAqB,GAAAM,SAEA3B,EAAAqB,GAAAO,WAAA,EACAT,OAAAC,YAAAE,EAAAG,QAAAzB,GAAqC0B,UAAA,WAErC1B,GAAAU,GAAAC,cAGAI,EAAAf,EAAAqB,GAAAM,QAAAZ,EAIAf,EAAAU,GAAAE,GACAZ,EAAAU,GAAAE,EAAAG,EACAN,IAGAT,EAAAU,GAAAmB,QAAApB,KAGAT,EAAAU,IACAE,EAAAG,EACAc,QAAApB,GAAAqB,EAAA5C,KAAAc,EAAA,OACA+B,WAAA/B,EAAAiB,QAEAjB,EAAAe,IAAAL,EAGAV,EAAAiB,SACAjB,EAAAiB,OAAA,GAGAe,OAAAC,eAAAjC,EAAA,UACAkC,MAAAlC,EAAAU,GAAAqB,cAIAI,EAAAnC,IAGAA,EAAAE,MAAAkC,gBAAA,QAAArB,EAAA,KACAf,EAAAE,MAAAmC,mBAAAnC,EAAA,6BACAF,EAAAE,MAAAoC,iBAAA,YAEA,aAAAC,KAAArC,EAAA,gBAEAF,EAAAU,GAAA8B,IACAxC,EAAAU,GAAA8B,EAAA,GAAAC,OACAzC,EAAAU,GAAA8B,EAAAzB,OAQA,QAAA2B,KAEA,MAAA1C,GAAAU,GAAA8B,EAAAG,kBACA3C,EAAAU,GAAA8B,EAAAG,aAAA3C,EAAA4C,OAAA5C,EAAAU,GAAA8B,EAAAK,cAAA7C,EAAA8C,OACA9C,EAAAE,MAAA6C,eAAA,UAEA/C,EAAAE,MAAA6C,eAAA,YAIAC,YAAAN,EAAA,SAGA1C,EAAAE,MAAA6C,eAAA7C,EAAA,cAAA+C,QAAA,eAAAA,QAAA,qBAIA,QAAAd,GAAAnC,GACA,GAAAkD,IACAC,IAAA,WACA,MAAAnD,GAAAU,GAAAE,GAEAwC,IAAA,SAAArC,GAGA,aAFAf,GAAAU,GAAA8B,EACAhC,EAAAR,EAAAe,GACAA,GAGAiB,QAAAC,eAAAjC,EAAA,MAAAkD,GACAlB,OAAAC,eAAAjC,EAAA,cAA0CmD,IAAAD,EAAAC,MAG1C,QAAAE,KACAC,IACAC,iBAAAC,UAAAC,aAAA,SAAAC,GACA,OAAAC,KAAAjD,IAAA,QAAAgD,GAAA,WAAAA,EAGA5B,EAAA5C,KAAAyE,KAAAD,GAFAC,KAAAjD,GAAAgD,EAAA,SAKAH,iBAAAC,UAAAI,aAAA,SAAAF,EAAAxB,IACAyB,KAAAjD,IAAA,QAAAgD,GAAA,WAAAA,EAGAG,EAAA3E,KAAAyE,KAAAD,EAAAxB,GAFAyB,KAAA,QAAAD,EAAA,MAAAA,EAAA,QAAAI,OAAA5B,KAQA,QAAA6B,GAAAC,EAAAC,GACA,GAAAC,IAAAC,IAAAH,CAGA,IAFAC,QACAD,KAAA,MACAV,IAAAW,EAAApD,SACA,QAIA,iBAAAmD,GACAA,EAAApE,SAAAwE,iBAAA,OACEJ,EAAAK,SACFL,MAIA,QAAAxB,GAAA,EAAgBA,EAAAwB,EAAAK,OAAiB7B,IACjCwB,EAAAxB,GAAA9B,GAAAsD,EAAAxB,GAAA9B,IAAAuD,EACAzD,EAAAwD,EAAAxB,GAGA0B,KACAtE,SAAA0E,KAAAxE,iBAAA,gBAAAyE,GACA,QAAAA,EAAAC,OAAAC,SACAV,EAAAQ,EAAAC,QACA3D,SAAAoD,EAAApD,aAGG,GACHsD,GAAA,EACAH,EAAA,OAIAC,EAAAS,SACAvD,OAAArB,iBAAA,SAAAiE,EAAAY,KAAA,KAAAX,GACAnD,SAAAoD,EAAApD,YA/MA,GAAAH,GAAA,qFACAJ,EAAA,kDACAsE,EAAA,GAAAnC,OACA3B,EAAA,cAAA8D,GAAA1E,MACAoD,EAAA,mBAAAsB,GAAA1E,MACAgB,EAAA,gBAAA0D,GAAA5D,WACAc,EAAA8C,EAAAnB,aACAI,EAAAe,EAAAhB,aACAO,GAAA,CA4MAJ,GAAAjD,oBACAiD,EAAAT,yBAEAD,IAEAtE,EAAAD,QAAAiF","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _objectFitImages = __webpack_require__(1);\n\t\n\tvar _objectFitImages2 = _interopRequireDefault(_objectFitImages);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tdocument.createElement(\"picture\");\n\t\n\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\t(0, _objectFitImages2.default)();\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar ಠ = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='; // transparent image, used as accessor and replacing image\n\tvar propRegex = /(object-fit|object-position)\\s*:\\s*([-\\w\\s%]+)/g;\n\tvar testImg = new Image();\n\tvar supportsObjectFit = 'object-fit' in testImg.style;\n\tvar supportsObjectPosition = 'object-position' in testImg.style;\n\tvar supportsCurrentSrc = typeof testImg.currentSrc === 'string';\n\tvar nativeGetAttribute = testImg.getAttribute;\n\tvar nativeSetAttribute = testImg.setAttribute;\n\tvar autoModeEnabled = false;\n\t\n\tfunction getStyle(el) {\n\t\tvar style = getComputedStyle(el).fontFamily;\n\t\tvar parsed;\n\t\tvar props = {};\n\t\twhile ((parsed = propRegex.exec(style)) !== null) {\n\t\t\tprops[parsed[1]] = parsed[2];\n\t\t}\n\t\treturn props;\n\t}\n\t\n\tfunction fixOne(el, requestedSrc) {\n\t\tif (el[ಠ].parsingSrcset) {\n\t\t\treturn;\n\t\t}\n\t\tvar style = getStyle(el);\n\t\tstyle['object-fit'] = style['object-fit'] || 'fill'; // default value\n\t\n\t\t// If the fix was already applied, don't try to skip fixing,\n\t\t// - because once you go ofi you never go back.\n\t\t// - Wait, that doesn't rhyme.\n\t\t// - This ain't rap, bro.\n\t\tif (!el[ಠ].s) {\n\t\t\t// fill is the default behavior so no action is necessary\n\t\t\tif (style['object-fit'] === 'fill') {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Where object-fit is supported and object-position isn't (Safari < 10)\n\t\t\tif (!el[ಠ].skipTest && // unless user wants to apply regardless of browser support\n\t\t\tsupportsObjectFit && // if browser already supports object-fit\n\t\t\t!style['object-position'] // unless object-position is used\n\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t}\n\t\n\t\tvar src = el.currentSrc || el.src;\n\t\n\t\tif (requestedSrc) {\n\t\t\t// explicitly requested src takes precedence\n\t\t\t// TODO: this still should overwrite srcset\n\t\t\tsrc = requestedSrc;\n\t\t} else if (el.srcset && !supportsCurrentSrc && window.picturefill) {\n\t\t\tvar pf = window.picturefill._.ns;\n\t\t\t// prevent infinite loop\n\t\t\t// fillImg sets the src which in turn calls fixOne\n\t\t\tel[ಠ].parsingSrcset = true;\n\t\n\t\t\t// parse srcset with picturefill where currentSrc isn't available\n\t\t\tif (!el[pf] || !el[pf].evaled) {\n\t\t\t\t// force synchronous srcset parsing\n\t\t\t\twindow.picturefill._.fillImg(el, { reselect: true });\n\t\t\t}\n\t\n\t\t\tif (!el[pf].curSrc) {\n\t\t\t\t// force picturefill to parse srcset\n\t\t\t\tel[pf].supported = false;\n\t\t\t\twindow.picturefill._.fillImg(el, { reselect: true });\n\t\t\t}\n\t\t\tdelete el[ಠ].parsingSrcset;\n\t\n\t\t\t// retrieve parsed currentSrc, if any\n\t\t\tsrc = el[pf].curSrc || src;\n\t\t}\n\t\n\t\t// store info on object for later use\n\t\tif (el[ಠ].s) {\n\t\t\tel[ಠ].s = src;\n\t\t\tif (requestedSrc) {\n\t\t\t\t// the attribute reflects the user input\n\t\t\t\t// the property is the resolved URL\n\t\t\t\tel[ಠ].srcAttr = requestedSrc;\n\t\t\t}\n\t\t} else {\n\t\t\tel[ಠ] = {\n\t\t\t\ts: src,\n\t\t\t\tsrcAttr: requestedSrc || nativeGetAttribute.call(el, 'src'),\n\t\t\t\tsrcsetAttr: el.srcset\n\t\t\t};\n\t\t\tel.src = ಠ;\n\t\n\t\t\t// remove srcset because it overrides src\n\t\t\tif (el.srcset) {\n\t\t\t\tel.srcset = '';\n\t\n\t\t\t\t// restore non-browser-readable srcset property\n\t\t\t\tObject.defineProperty(el, 'srcset', {\n\t\t\t\t\tvalue: el[ಠ].srcsetAttr\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tkeepSrcUsable(el);\n\t\t}\n\t\n\t\tel.style.backgroundImage = 'url(\"' + src + '\")';\n\t\tel.style.backgroundPosition = style['object-position'] || 'center';\n\t\tel.style.backgroundRepeat = 'no-repeat';\n\t\n\t\tif (/scale-down/.test(style['object-fit'])) {\n\t\t\t// `object-fit: scale-down` is either `contain` or `auto`\n\t\t\tif (!el[ಠ].i) {\n\t\t\t\tel[ಠ].i = new Image();\n\t\t\t\tel[ಠ].i.src = src;\n\t\t\t}\n\t\n\t\t\t// naturalWidth is only available when the image headers are loaded,\n\t\t\t// this loop will poll it every 100ms.\n\t\t\t// There's currently no check to prevent this loop from starting twice\n\t\t\t// as a consequence of calling ofi() twice on the same image, but it's light\n\t\t\t// and causes no issues, so it's not worth ensuring that it doesn't.\n\t\t\t(function loop() {\n\t\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=495908\n\t\t\t\tif (el[ಠ].i.naturalWidth) {\n\t\t\t\t\tif (el[ಠ].i.naturalWidth > el.width || el[ಠ].i.naturalHeight > el.height) {\n\t\t\t\t\t\tel.style.backgroundSize = 'contain';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tel.style.backgroundSize = 'auto';\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsetTimeout(loop, 100);\n\t\t\t})();\n\t\t} else {\n\t\t\tel.style.backgroundSize = style['object-fit'].replace('none', 'auto').replace('fill', '100% 100%');\n\t\t}\n\t}\n\t\n\tfunction keepSrcUsable(el) {\n\t\tvar descriptors = {\n\t\t\tget: function () {\n\t\t\t\treturn el[ಠ].s;\n\t\t\t},\n\t\t\tset: function (src) {\n\t\t\t\tdelete el[ಠ].i; // scale-down's img sizes need to be updated too\n\t\t\t\tfixOne(el, src);\n\t\t\t\treturn src;\n\t\t\t}\n\t\t};\n\t\tObject.defineProperty(el, 'src', descriptors);\n\t\tObject.defineProperty(el, 'currentSrc', { get: descriptors.get }); // it should be read-only\n\t}\n\t\n\tfunction hijackAttributes() {\n\t\tif (!supportsObjectPosition) {\n\t\t\tHTMLImageElement.prototype.getAttribute = function (name) {\n\t\t\t\tif (this[ಠ] && (name === 'src' || name === 'srcset')) {\n\t\t\t\t\treturn this[ಠ][name + 'Attr'];\n\t\t\t\t}\n\t\t\t\treturn nativeGetAttribute.call(this, name);\n\t\t\t};\n\t\n\t\t\tHTMLImageElement.prototype.setAttribute = function (name, value) {\n\t\t\t\tif (this[ಠ] && (name === 'src' || name === 'srcset')) {\n\t\t\t\t\tthis[name === 'src' ? 'src' : name + 'Attr'] = String(value);\n\t\t\t\t} else {\n\t\t\t\t\tnativeSetAttribute.call(this, name, value);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\t\n\tfunction fix(imgs, opts) {\n\t\tvar startAutoMode = !autoModeEnabled && !imgs;\n\t\topts = opts || {};\n\t\timgs = imgs || 'img';\n\t\tif (supportsObjectPosition && !opts.skipTest) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\t// use imgs as a selector or just select all images\n\t\tif (typeof imgs === 'string') {\n\t\t\timgs = document.querySelectorAll('img');\n\t\t} else if (!imgs.length) {\n\t\t\timgs = [imgs];\n\t\t}\n\t\n\t\t// apply fix to all\n\t\tfor (var i = 0; i < imgs.length; i++) {\n\t\t\timgs[i][ಠ] = imgs[i][ಠ] || opts;\n\t\t\tfixOne(imgs[i]);\n\t\t}\n\t\n\t\tif (startAutoMode) {\n\t\t\tdocument.body.addEventListener('load', function (e) {\n\t\t\t\tif (e.target.tagName === 'IMG') {\n\t\t\t\t\tfix(e.target, {\n\t\t\t\t\t\tskipTest: opts.skipTest\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, true);\n\t\t\tautoModeEnabled = true;\n\t\t\timgs = 'img'; // reset to a generic selector for watchMQ\n\t\t}\n\t\n\t\t// if requested, watch media queries for object-fit change\n\t\tif (opts.watchMQ) {\n\t\t\twindow.addEventListener('resize', fix.bind(null, imgs, {\n\t\t\t\tskipTest: opts.skipTest\n\t\t\t}));\n\t\t}\n\t}\n\t\n\tfix.supportsObjectFit = supportsObjectFit;\n\tfix.supportsObjectPosition = supportsObjectPosition;\n\t\n\thijackAttributes();\n\t\n\tmodule.exports = fix;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b10b5d4ffd3573438c12\n **/","import objectFitPolyfill from 'object-fit-images';\r\n\r\ndocument.createElement( \"picture\" );\r\n\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n\tobjectFitPolyfill();\r\n});\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/js/index.js\n **/","'use strict';\n\nvar ಠ = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='; // transparent image, used as accessor and replacing image\nvar propRegex = /(object-fit|object-position)\\s*:\\s*([-\\w\\s%]+)/g;\nvar testImg = new Image();\nvar supportsObjectFit = 'object-fit' in testImg.style;\nvar supportsObjectPosition = 'object-position' in testImg.style;\nvar supportsCurrentSrc = typeof testImg.currentSrc === 'string';\nvar nativeGetAttribute = testImg.getAttribute;\nvar nativeSetAttribute = testImg.setAttribute;\nvar autoModeEnabled = false;\n\nfunction getStyle(el) {\n\tvar style = getComputedStyle(el).fontFamily;\n\tvar parsed;\n\tvar props = {};\n\twhile ((parsed = propRegex.exec(style)) !== null) {\n\t\tprops[parsed[1]] = parsed[2];\n\t}\n\treturn props;\n}\n\nfunction fixOne(el, requestedSrc) {\n\tif (el[ಠ].parsingSrcset) {\n\t\treturn;\n\t}\n\tvar style = getStyle(el);\n\tstyle['object-fit'] = style['object-fit'] || 'fill'; // default value\n\n\t// If the fix was already applied, don't try to skip fixing,\n\t// - because once you go ofi you never go back.\n\t// - Wait, that doesn't rhyme.\n\t// - This ain't rap, bro.\n\tif (!el[ಠ].s) {\n\t\t// fill is the default behavior so no action is necessary\n\t\tif (style['object-fit'] === 'fill') {\n\t\t\treturn;\n\t\t}\n\n\t\t// Where object-fit is supported and object-position isn't (Safari < 10)\n\t\tif (!el[ಠ].skipTest && // unless user wants to apply regardless of browser support\n\t\tsupportsObjectFit && // if browser already supports object-fit\n\t\t!style['object-position'] // unless object-position is used\n\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\n\tvar src = el.currentSrc || el.src;\n\n\tif (requestedSrc) {\n\t\t// explicitly requested src takes precedence\n\t\t// TODO: this still should overwrite srcset\n\t\tsrc = requestedSrc;\n\t} else if (el.srcset && !supportsCurrentSrc && window.picturefill) {\n\t\tvar pf = window.picturefill._.ns;\n\t\t// prevent infinite loop\n\t\t// fillImg sets the src which in turn calls fixOne\n\t\tel[ಠ].parsingSrcset = true;\n\n\t\t// parse srcset with picturefill where currentSrc isn't available\n\t\tif (!el[pf] || !el[pf].evaled) {\n\t\t\t// force synchronous srcset parsing\n\t\t\twindow.picturefill._.fillImg(el, { reselect: true });\n\t\t}\n\n\t\tif (!el[pf].curSrc) {\n\t\t\t// force picturefill to parse srcset\n\t\t\tel[pf].supported = false;\n\t\t\twindow.picturefill._.fillImg(el, { reselect: true });\n\t\t}\n\t\tdelete el[ಠ].parsingSrcset;\n\n\t\t// retrieve parsed currentSrc, if any\n\t\tsrc = el[pf].curSrc || src;\n\t}\n\n\t// store info on object for later use\n\tif (el[ಠ].s) {\n\t\tel[ಠ].s = src;\n\t\tif (requestedSrc) {\n\t\t\t// the attribute reflects the user input\n\t\t\t// the property is the resolved URL\n\t\t\tel[ಠ].srcAttr = requestedSrc;\n\t\t}\n\t} else {\n\t\tel[ಠ] = {\n\t\t\ts: src,\n\t\t\tsrcAttr: requestedSrc || nativeGetAttribute.call(el, 'src'),\n\t\t\tsrcsetAttr: el.srcset\n\t\t};\n\t\tel.src = ಠ;\n\n\t\t// remove srcset because it overrides src\n\t\tif (el.srcset) {\n\t\t\tel.srcset = '';\n\n\t\t\t// restore non-browser-readable srcset property\n\t\t\tObject.defineProperty(el, 'srcset', {\n\t\t\t\tvalue: el[ಠ].srcsetAttr\n\t\t\t});\n\t\t}\n\n\t\tkeepSrcUsable(el);\n\t}\n\n\tel.style.backgroundImage = 'url(\"' + src + '\")';\n\tel.style.backgroundPosition = style['object-position'] || 'center';\n\tel.style.backgroundRepeat = 'no-repeat';\n\n\tif (/scale-down/.test(style['object-fit'])) {\n\t\t// `object-fit: scale-down` is either `contain` or `auto`\n\t\tif (!el[ಠ].i) {\n\t\t\tel[ಠ].i = new Image();\n\t\t\tel[ಠ].i.src = src;\n\t\t}\n\n\t\t// naturalWidth is only available when the image headers are loaded,\n\t\t// this loop will poll it every 100ms.\n\t\t// There's currently no check to prevent this loop from starting twice\n\t\t// as a consequence of calling ofi() twice on the same image, but it's light\n\t\t// and causes no issues, so it's not worth ensuring that it doesn't.\n\t\t(function loop() {\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=495908\n\t\t\tif (el[ಠ].i.naturalWidth) {\n\t\t\t\tif (el[ಠ].i.naturalWidth > el.width || el[ಠ].i.naturalHeight > el.height) {\n\t\t\t\t\tel.style.backgroundSize = 'contain';\n\t\t\t\t} else {\n\t\t\t\t\tel.style.backgroundSize = 'auto';\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsetTimeout(loop, 100);\n\t\t})();\n\t} else {\n\t\tel.style.backgroundSize = style['object-fit'].replace('none', 'auto').replace('fill', '100% 100%');\n\t}\n}\n\nfunction keepSrcUsable(el) {\n\tvar descriptors = {\n\t\tget: function () {\n\t\t\treturn el[ಠ].s;\n\t\t},\n\t\tset: function (src) {\n\t\t\tdelete el[ಠ].i; // scale-down's img sizes need to be updated too\n\t\t\tfixOne(el, src);\n\t\t\treturn src;\n\t\t}\n\t};\n\tObject.defineProperty(el, 'src', descriptors);\n\tObject.defineProperty(el, 'currentSrc', { get: descriptors.get }); // it should be read-only\n}\n\nfunction hijackAttributes() {\n\tif (!supportsObjectPosition) {\n\t\tHTMLImageElement.prototype.getAttribute = function (name) {\n\t\t\tif (this[ಠ] && (name === 'src' || name === 'srcset')) {\n\t\t\t\treturn this[ಠ][name + 'Attr'];\n\t\t\t}\n\t\t\treturn nativeGetAttribute.call(this, name);\n\t\t};\n\n\t\tHTMLImageElement.prototype.setAttribute = function (name, value) {\n\t\t\tif (this[ಠ] && (name === 'src' || name === 'srcset')) {\n\t\t\t\tthis[name === 'src' ? 'src' : name + 'Attr'] = String(value);\n\t\t\t} else {\n\t\t\t\tnativeSetAttribute.call(this, name, value);\n\t\t\t}\n\t\t};\n\t}\n}\n\nfunction fix(imgs, opts) {\n\tvar startAutoMode = !autoModeEnabled && !imgs;\n\topts = opts || {};\n\timgs = imgs || 'img';\n\tif (supportsObjectPosition && !opts.skipTest) {\n\t\treturn false;\n\t}\n\n\t// use imgs as a selector or just select all images\n\tif (typeof imgs === 'string') {\n\t\timgs = document.querySelectorAll('img');\n\t} else if (!imgs.length) {\n\t\timgs = [imgs];\n\t}\n\n\t// apply fix to all\n\tfor (var i = 0; i < imgs.length; i++) {\n\t\timgs[i][ಠ] = imgs[i][ಠ] || opts;\n\t\tfixOne(imgs[i]);\n\t}\n\n\tif (startAutoMode) {\n\t\tdocument.body.addEventListener('load', function (e) {\n\t\t\tif (e.target.tagName === 'IMG') {\n\t\t\t\tfix(e.target, {\n\t\t\t\t\tskipTest: opts.skipTest\n\t\t\t\t});\n\t\t\t}\n\t\t}, true);\n\t\tautoModeEnabled = true;\n\t\timgs = 'img'; // reset to a generic selector for watchMQ\n\t}\n\n\t// if requested, watch media queries for object-fit change\n\tif (opts.watchMQ) {\n\t\twindow.addEventListener('resize', fix.bind(null, imgs, {\n\t\t\tskipTest: opts.skipTest\n\t\t}));\n\t}\n}\n\nfix.supportsObjectFit = supportsObjectFit;\nfix.supportsObjectPosition = supportsObjectPosition;\n\nhijackAttributes();\n\nmodule.exports = fix;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/object-fit-images/dist/ofi.common-js.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}